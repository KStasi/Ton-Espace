;; Exchange Contract

(cell) load_data() {
  return get_data().begin_parse().preload_dict();
}

() store_offer(s_addr, in_msg) impure {
  cell offers = load_data();
  if (offers.null?()) {
      offers = new_dict();
  }
  var (contr_wc, contr_addr, price) = (in_msg~load_int(8), in_msg~load_uint(256), in_msg~load_grams());
  slice value = begin_cell()
      .store_int(contr_wc, 8)
      .store_uint(contr_addr, 256)
      .store_slice(s_addr)
      .store_grams(price)
      .end_cell().begin_parse();
  ;; change to add
  offers~idict_set(256, slice_hash(contr_wc, contr_addr), value);
  store_data(offers);

}

;; (int, int, int, int, int) getoffer() method_id {}
;; () buy(s_addr, in_msg) impure {}
;; () claim_token(s_addr, in_msg) impure {}

() recv_external(slice in_msg) impure {
  slice ds = get_data().begin_parse();
  var (init, offers) = (ds~load_int(1), ds~load_dict()));
  ifnot(init) {
    accept_message();
    set_data(begin_cell()
      .store_dict(offers)
      .end_cell());
  }
}

(int) validate_owner(slice s_addr) impure {
  var (sender_wc, sender_addr) = s_addr.parse_std_addr();
  var (owner_wc, owner_addr) = load_data();
  ifnot((owner_wc == sender_wc) & (owner_addr == sender_addr)) {
    return (0);
  }
  return (1);
}

() recv_internal(cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg_cell.begin_parse();
  var flags = cs~load_uint(4); 
  if (flags & 1) {
    return ();
  }
  var s_addr = cs~load_msg_addr();
  if (in_msg.slice_empty?()) {
    return ();
  }
  int op = in_msg~load_uint(32);
  if (op == 0) {
    return ();
  }
  int query_id = in_msg~load_uint(64);
  if (op == 0xaaeeee) {
    return store_offer(s_addr, in_msg);
  }
  if (op == 0xaaeeff) {
    return buy(s_addr, in_msg);
  }
  return ();
}

;; Get methods
(int, int) seqno() method_id {
  return load_data();
}
